<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-13 Thu 15:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>All About Bloom Filters for Hash Joins</title>
<meta name="author" content="Sasha" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="css/stylesheet.css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">All About Bloom Filters for Hash Joins</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org73f61a7">1. Introduction</a>
<ul>
<li><a href="#org5237b97">1.1. Formal Definition</a>
<ul>
<li><a href="#orgf321579">1.1.1. Algorithm Description</a></li>
<li><a href="#org1cd3ae9">1.1.2. Choosing \(m\) and \(k\)</a></li>
</ul>
</li>
<li><a href="#org0b9a6da">1.2. Practical Implementation</a>
<ul>
<li><a href="#org623a3d3">1.2.1. Blocked Bloom Filters</a></li>
<li><a href="#org3b5d822">1.2.2. Bit Patterns</a></li>
<li><a href="#org569269f">1.2.3. Register Blocking</a></li>
<li><a href="#org4cecc63">1.2.4. Regaining Randomness</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga2aa42c">2. Binary Hash Join</a>
<ul>
<li><a href="#org2764f31">2.1. Build-side Bloom filter</a></li>
<li><a href="#org882fadc">2.2. Probe-side Bloom filter</a></li>
<li><a href="#org8675c80">2.3. Fuzzy Hash Join</a></li>
</ul>
</li>
<li><a href="#orgea3bbe6">3. Chain of Binary Hash Joins</a>
<ul>
<li><a href="#orgfca3bc9">3.1. Bloom Filter Pushdown</a></li>
</ul>
</li>
<li><a href="#org0e23c9b">4. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-org73f61a7" class="outline-2">
<h2 id="org73f61a7"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
A Bloom filter is a probabilistic data structure which provides an efficient way to query whether an element is a member
of a set. It is typically built over some backing structure (e.g. a hash table), and is used to avoid expensive lookups
to the backing structure. A Bloom filter is designed to be space-efficient and cheap to query, but has a probability of returning
a false positive (i.e. saying an element is in the backing structure when it is not). Bloom filters are static: they have a
build phase and a probe phase. That is, they cannot grow dynamically, and once probing begins, inserting more is not valid.
</p>
</div>

<div id="outline-container-org5237b97" class="outline-3">
<h3 id="org5237b97"><span class="section-number-3">1.1.</span> Formal Definition</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Bloom filters are parameterized by \(n, \epsilon\), where \(n\) is the number of elements to be inserted and
\(\epsilon\) is the desired false positive rate. An \((n, \epsilon)-\) Bloom filter \(B\) over some set \(S\) provides two
operations:
</p>
<ul class="org-ul">
<li><code>insert</code> takes some \(x \in S\) and inserts it into the structure.</li>
<li><code>query</code> takes some \(y \in S\) and (assuming the number of inserted elements is at most \(n\)):
<ul class="org-ul">
<li>If <code>insert(y)</code> was called previously, then <code>query(y)</code> returns <code>true</code>.</li>
<li>If <code>insert(y)</code> was not called previously, then <code>query(y)</code> returns <code>false</code> (the expected result) with
probability \(1 - \epsilon\) or <code>true</code> with probability \(\epsilon\) (a false positive).</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgf321579" class="outline-4">
<h4 id="orgf321579"><span class="section-number-4">1.1.1.</span> Algorithm Description</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
An \((n, \epsilon)-\) Bloom filter \(B\) is an array of \(m\) bits and \(k\) hash functions, where \(m\) and \(k\) are picked in some
combination to guarantee the false positive rate is at most \(\epsilon\) when the number of inserted elements is at most \(n\).
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">uint64_t</span> <span style="color: #fcfcfc;">ComputeHash</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>, <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">hash_idx</span>);

<span style="color: #FF16B0;">struct</span> <span style="color: #46BDFF;">BloomFilter</span>
{
    <span style="color: #46BDFF;">int</span> <span style="color: #fcfcfc;">ComputeNumBits</span>();
    <span style="color: #46BDFF;">int</span> <span style="color: #fcfcfc;">ComputeNumHashFns</span>();

    <span style="color: #fcfcfc;">BloomFilter</span>(<span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #46BDFF;">float</span> <span style="color: #eedd82;">eps</span>) : n(n), epsilon(eps)
    {
        <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">m</span> = ComputeNumBits();
        bv = <span style="color: #FF16B0;">new</span> <span style="color: #46BDFF;">uint8_t</span>[(m + 7) / 8];
    }

    ~<span style="color: #fcfcfc;">BloomFilter</span>() { <span style="color: #FF16B0;">delete</span>[] bv }

    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">n</span>;
    <span style="color: #46BDFF;">float</span> <span style="color: #eedd82;">epsilon</span>;

    <span style="color: #46BDFF;">void</span> <span style="color: #fcfcfc;">Insert</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>);
    <span style="color: #46BDFF;">bool</span> <span style="color: #fcfcfc;">Query</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>);

    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">bv</span>;
};
</pre>
</div>

<p>
To <code>insert</code>, we simply evaluate all \(k\) hash functions on the inserted element and set the corresponding bit in the bit vector.
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">void</span> <span style="color: #96A1FF;">BloomFilter</span>::<span style="color: #fcfcfc;">Insert</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">k</span> = ComputeNumHashFns();
    <span style="color: #FF16B0;">for</span>(<span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; k; i++)
    {
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row, i) % m;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">bit_idx</span> = hash % 8;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">byte_idx</span> = hash / 8;
        bv[byte_idx] |= (1 &lt;&lt; bit_idx);
    }
}
</pre>
</div>

<p>
Similarly, to <code>query</code> we just check if all of the corresponding bits are set in the bit vector.
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">bool</span> <span style="color: #96A1FF;">BloomFilter</span>::<span style="color: #fcfcfc;">Query</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">k</span> = ComputeNumHashFns();
    <span style="color: #46BDFF;">bool</span> <span style="color: #eedd82;">result</span> = <span style="color: #96A1FF;">true</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; k; i++)
    {
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row, i) % m;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">bit_idx</span> = hash % 8;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">byte_idx</span> = hash / 8;
        result &amp;= (bv[byte_idx] &gt;&gt; bit_idx) &amp; 1;
    }
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1cd3ae9" class="outline-4">
<h4 id="org1cd3ae9"><span class="section-number-4">1.1.2.</span> Choosing \(m\) and \(k\)</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
For a given \(n, \epsilon\), we'd like to pick \(m, k\) such that \(m\) and \(k\) are minimized while respecting the bound on
false positive rate. We can parameterize the relationship between \(\epsilon\) and \(m\) using a <i>bits-per-element</i> metric,
\(c = \frac{m}{n}\). It has been shown that for a given \(\epsilon\), the minimum bits per element is \(c = -1.44\log_2{\epsilon}\),
with the corresponding number of hash functions being \(k = -\log_2{\epsilon}\) (1). Interestingly, \(k\) is independent
of \(n\).
</p>

<p>
It can also be useful to view \(c\) as the parameter, computing the expected false positive rate. Simply the equation backwards,
we get that \(\epsilon = 2^{\frac{c}{-1.44}}\). As you can see below, there are diminishing returns on \(c\) past around \(10\). 
</p>

<p>
<img src="./img/k_vs_eps.png" alt="k_vs_eps.png" /> <img src="./img/eps_vs_c.png" alt="eps_vs_c.png" />
</p>

<p>
Simply translating these bounds completes the bloom filter:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">int</span> <span style="color: #96A1FF;">BloomFilter</span>::<span style="color: #fcfcfc;">ComputeNumBits</span>()
{
    <span style="color: #FF16B0;">return</span> <span style="color: #FF16B0;">static_cast</span>&lt;<span style="color: #46BDFF;">int</span>&gt;(-1.44 * n * <span style="color: #96A1FF;">std</span>::log2(epsilon) + 0.5);
}

<span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">int</span> <span style="color: #96A1FF;">BloomFilter</span>::<span style="color: #fcfcfc;">ComputeNumHashFns</span>()
{
    <span style="color: #FF16B0;">return</span> <span style="color: #FF16B0;">static_cast</span>&lt;<span style="color: #46BDFF;">int</span>&gt;(-<span style="color: #96A1FF;">std</span>::log2(epsilon) + 0.5);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0b9a6da" class="outline-3">
<h3 id="org0b9a6da"><span class="section-number-3">1.2.</span> Practical Implementation</h3>
<div class="outline-text-3" id="text-1-2">
<p>
While conceptually elegant, the standard Bloom filter is extremely inefficient. Even setting aside the inefficiency of evaluating
several hash functions on the same data, consider a Bloom filter larger than cache. Assuming perfect hash functions, each bit
is set with probability \(\frac{1}{2}\). Since the positions of each bit is random, each lookup will incur a cache miss. For negative
lookups, the expected number of misses is thus \(2\), and a positive lookup will <i>require</i> \(k\) cache misses!
</p>
</div>

<div id="outline-container-org623a3d3" class="outline-4">
<h4 id="org623a3d3"><span class="section-number-4">1.2.1.</span> Blocked Bloom Filters</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
The classic way to deal with cache misses is increasing locality, and Bloom filters are no different. We cannot hope to have
fewer than one cache miss per lookup in the general case. However, if each bit lookup after the first happens within a cache line,
the only cache miss will be for fetching that cache line. Thus we can divide a Bloom filter into many smaller, cache line-sized
Bloom filters called "blocks". The first hash function will index a block, and the other \(k - 1\) functions will operate as in
the standard filter.
</p>

<p>
Take note that the false positive rate of a blocked Bloom filter is higher, as each block has its own \(n\). More precisely, if there
are \(b\) blocks, each entry has probability of \(\frac{1}{b}\) of being in a given block. If \(X_{ij}\) is an indicator variable of
whether entry \(i\) is in block \(j\), the number of entries in block \(j\) \(n_j = \sum\limits_{i = 1}^{n} X_{ij}\), which implies that
\(n_j\) is a random variable following the Binomial distribution \(B(n, \frac{1}{b})\). As such some blocks will be underloaded and
others will be overloaded. While the overall effect on space efficiency is not immediately clear, Putze, Felix and Sanders, Peter and Singler, Johannes
give a detailed analysis. They show a slight increase in false positive rate, and provide a detailed analysis of the space overhead
needed to compensate.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">uint8_t</span> *<span style="color: #96A1FF;">BlockedBloomFilter</span>::<span style="color: #fcfcfc;">GetBlock</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">num_blocks</span> = m / CACHE_LINE_BITS;
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">block_idx</span> = ComputeHash(row, 0) % num_blocks;
    <span style="color: #FF16B0;">return</span> bv + block_idx;
}

<span style="color: #46BDFF;">void</span> <span style="color: #96A1FF;">BlockedBloomFilter</span>::<span style="color: #fcfcfc;">Insert</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">k</span> = ComputeNumHashFns();
    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    <span style="color: #FF16B0;">for</span>(<span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; k; i++)
    {
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row, i) % CACHE_LINE_BITS;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">bit_idx</span> = hash % 8;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">byte_idx</span> = hash / 8;
        block[byte_idx] |= (1 &lt;&lt; bit_idx);
    }
}

<span style="color: #46BDFF;">bool</span> <span style="color: #96A1FF;">BlockedBloomFilter</span>::<span style="color: #fcfcfc;">Query</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">k</span> = ComputeNumHashFns();
    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    <span style="color: #46BDFF;">bool</span> <span style="color: #eedd82;">result</span> = <span style="color: #96A1FF;">true</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; k; i++)
    {
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row, i) % CACHE_LINE_BITS;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">bit_idx</span> = hash % 8;
        <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">byte_idx</span> = hash / 8;
        result &amp;= (1 &lt;&lt; bit_idx);
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b5d822" class="outline-4">
<h4 id="org3b5d822"><span class="section-number-4">1.2.2.</span> Bit Patterns</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Cache misses aside, the other major overhead of the classic Bloom filter is the evaluation of several hash functions. Hash
functions can be expensive, and setting \(k - 1\) bits separately can quickly eat up cycles. Rather than evaluating \(k\) hash
functions, we can use a single hash function to choose a random entry from a table of bit patterns. Each bit pattern is
cache line-sized, and has \(k\) bits set. Using SIMD instructions (such as AVX2), a query be done very efficiently, comparing
parts of the block to the pattern in parallel.
</p>

<p>
Bit Patterns come at the cost of once again increasing false positive rate due to there being a chance of two elements hashing
to the same pattern. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">PATTERNS</span>; <span style="color: #525863;">// </span><span style="color: #525863;">Computed in some clever fashion</span>
<span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">NUM_PATTERNS</span>;

<span style="color: #46BDFF;">uint8_t</span> *<span style="color: #fcfcfc;">GetPattern</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row); <span style="color: #525863;">// </span><span style="color: #525863;">We only have one hash function</span>
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">pattern_idx</span> = hash % NUM_PATTERNS;
    <span style="color: #FF16B0;">return</span> PATTERNS + pattern_idx * CACHE_LINE_BYTES;
}

<span style="color: #46BDFF;">void</span> <span style="color: #96A1FF;">PatternedBlockedBloomFilter</span>::<span style="color: #fcfcfc;">Insert</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">pattern</span> = GetPattern(row);
    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">pattern_lo</span> = _mm256_loadu_si256(pattern);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">pattern_hi</span> = _mm256_loadu_si256(pattern + <span style="color: #FF16B0;">sizeof</span>(__m256i));
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">block_lo</span> = _mm256_loadu_si256(block);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">block_hi</span> = _mm256_loadu_si256(block + <span style="color: #FF16B0;">sizeof</span>(__256i));
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">new_block_lo</span> = _mm256_or_si256(pattern_lo, block_lo);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">new_block_hi</span> = _mm256_or_si256(pattern_hi, block_hi);
    _mm256_storeu_si256(pattern, new_block_lo);
    _mm256_storeu_si256(pattern + <span style="color: #FF16B0;">sizeof</span>(__256i), new_block_hi);
}

<span style="color: #46BDFF;">bool</span> <span style="color: #96A1FF;">PatternedBlockedBloomFilter</span>::<span style="color: #fcfcfc;">Query</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">pattern</span> = GetPattern(row);
    <span style="color: #46BDFF;">uint8_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">pattern_lo</span> = _mm256_loadu_si256(pattern);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">pattern_hi</span> = _mm256_loadu_si256(pattern + <span style="color: #FF16B0;">sizeof</span>(__m256i));
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">block_lo</span> = _mm256_loadu_si256(block);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">block_hi</span> = _mm256_loadu_si256(block + <span style="color: #FF16B0;">sizeof</span>(__256i));
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">set_lo</span> = _mm256_and_si256(pattern_lo, block_lo);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">set_hi</span> = _mm256_and_si256(pattern_hi, block_hi);

    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">zero</span> = _mm256_setzero_si256();
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">cmp_lo</span> = _mm256_cmpeq_epi8(set_lo, zero);
    <span style="color: #46BDFF;">__m256i</span> <span style="color: #eedd82;">cmp_hi</span> = _mm256_cmpeq_epi8(set_hi, zero);
    <span style="color: #46BDFF;">bool</span> <span style="color: #eedd82;">nonzero_lo</span> = _mm256_movemask_epi8(cmp_lo) != 0xff;
    <span style="color: #46BDFF;">bool</span> <span style="color: #eedd82;">nonzero_hi</span> = _mm256_movemask_epi8(cmp_hi) != 0xff;
    <span style="color: #FF16B0;">return</span> nonzero_lo || nonzero_hi;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org569269f" class="outline-4">
<h4 id="org569269f"><span class="section-number-4">1.2.3.</span> Register Blocking</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
A Register-Blocked Bloom filter (2) sacrifices even more precision in favor of processing efficiency
by making the blocks machine word-sized (i.e. 32 or 64 bits). This allows lookups to be processed in one comparison instruction,
which is even more efficient than the SIMD implementation of the patterned blocked Bloom filter. In fact, it allows for multiple
parallel queries into the filter using SIMD, since a single SIMD register would be able to hold four or eight blocks. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">NUM_PATTERNS</span>;
<span style="color: #FF16B0;">static</span> <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">PATTERNS</span>[NUM_PATTERNS]; <span style="color: #525863;">// </span><span style="color: #525863;">Computed in some clever fashion</span>

<span style="color: #46BDFF;">uint64_t</span> <span style="color: #fcfcfc;">GetPattern</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row); <span style="color: #525863;">// </span><span style="color: #525863;">We only have one hash function</span>
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">pattern_idx</span> = hash % NUM_PATTERNS;
    <span style="color: #FF16B0;">return</span> PATTERNS[pattern_idx];
}

<span style="color: #46BDFF;">uint64_t</span> *<span style="color: #96A1FF;">PatternedRegisterBlockedBloomFilter</span>::<span style="color: #fcfcfc;">GetBlock</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">num_blocks</span> = m / 64;
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">block_idx</span> = ComputeHash(row) % num_blocks;
    <span style="color: #FF16B0;">return</span> <span style="color: #FF16B0;">reinterpret_cast</span>&lt;<span style="color: #46BDFF;">uint64_t</span> *&gt;(bv) + block_idx;
}

<span style="color: #46BDFF;">void</span> <span style="color: #96A1FF;">PatternedRegisterBlockedBloomFilter</span>::<span style="color: #fcfcfc;">Insert</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">pattern</span> = GetPattern(row);
    <span style="color: #46BDFF;">uint64_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    *block |= pattern;
}

<span style="color: #46BDFF;">bool</span> <span style="color: #96A1FF;">PatternedRegisterBlockedBloomFilter</span>::<span style="color: #fcfcfc;">Query</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">pattern</span> = GetPattern(row);
    <span style="color: #46BDFF;">uint64_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    <span style="color: #FF16B0;">return</span> *block &amp; pattern;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4cecc63" class="outline-4">
<h4 id="org4cecc63"><span class="section-number-4">1.2.4.</span> Regaining Randomness</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
This section shows some cheap ways of increasing the precision of the Bloom filter without sacrificing performance. The most
obvious is to observe that all of the example code above has used <code>mod</code> to map from a hash to an index (i.e. <code>hash % n</code>).
This reuses the same bottom bits of the hash repeatedly, making the pattern and block indices correlated in some sense. A
smarter strategy is to dedicate some bits of the hash to each component of the lookup. A cheap way (in particular for the
register-blocked Bloom filter) to generate more bit patterns without space overhead is by dedicating a few bits of the hash to
a rotation of the bit pattern. The remaining bits can then be used for the block index.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">LOG_NUM_PATTERNS</span> = 10;
<span style="color: #FF16B0;">static</span> <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">PATTERNS</span>[1 &lt;&lt; LOG_NUM_PATTERNS]; <span style="color: #525863;">// </span><span style="color: #525863;">Computed in some clever fashion</span>

<span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">ROTATE_BITS</span> = 6; <span style="color: #525863;">// </span><span style="color: #525863;">6 bits for a max rotation of 63</span>

<span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">PATTERN_MASK</span> = (1 &lt;&lt; LOG_NUM_PATTERNS) - 1;
<span style="color: #FF16B0;">static</span> <span style="color: #FF16B0;">constexpr</span> <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">ROTATE_MASK</span> = (1 &lt;&lt; 6) - 1;

<span style="color: #46BDFF;">uint64_t</span> <span style="color: #fcfcfc;">GetPattern</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row); <span style="color: #525863;">// </span><span style="color: #525863;">We only have one hash function</span>
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">pattern_idx</span> = hash &amp; PATTERN_MASK;
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">rotate</span> = (hash &gt;&gt; LOG_NUM_PATTERNS) &amp; ROTATE_MASK;
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">pattern</span> = Rotate64(PATTERNS[pattern_idx], rotate);
    <span style="color: #FF16B0;">return</span> pattern;
}

<span style="color: #46BDFF;">uint64_t</span> *<span style="color: #96A1FF;">PatternedRegisterBlockedBloomFilter</span>::<span style="color: #fcfcfc;">GetBlock</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">int</span> <span style="color: #eedd82;">num_blocks</span> = m / 64;
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">hash</span> = ComputeHash(row);
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">block_idx</span> = (hash &gt;&gt; (ROTATE_BITS + LOG_NUM_PATTERNS)) % num_blocks;
    <span style="color: #FF16B0;">return</span> <span style="color: #FF16B0;">reinterpret_cast</span>&lt;<span style="color: #46BDFF;">uint64_t</span> *&gt;(bv) + block_idx;
}

<span style="color: #46BDFF;">void</span> <span style="color: #96A1FF;">PatternedRegisterBlockedBloomFilter</span>::<span style="color: #fcfcfc;">Insert</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">pattern</span> = GetPattern(row);
    <span style="color: #46BDFF;">uint64_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    *block |= pattern;
}

<span style="color: #46BDFF;">bool</span> <span style="color: #96A1FF;">PatternedRegisterBlockedBloomFilter</span>::<span style="color: #fcfcfc;">Query</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span>)
{
    <span style="color: #46BDFF;">uint64_t</span> <span style="color: #eedd82;">pattern</span> = GetPattern(row);
    <span style="color: #46BDFF;">uint64_t</span> *<span style="color: #eedd82;">block</span> = GetBlock(row);
    <span style="color: #FF16B0;">return</span> *block &amp; pattern;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orga2aa42c" class="outline-2">
<h2 id="orga2aa42c"><span class="section-number-2">2.</span> Binary Hash Join</h2>
<div class="outline-text-2" id="text-2">
<p>
Hash Join is an algorithm for evaluating equijoins, where at least one of the join conditions is an equality between "key columns".
Hash join has two sides: build and probe (also called "right" and "left" respectively). We build a hash table mapping from key
column values to build-side rows. Then, for each probe-side key, hash it, lookup the matching build-side row, and output the matching
rows (assuming an inner join).
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">Dataset</span> <span style="color: #fcfcfc;">InnerHashJoin</span>(<span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">build_side</span>, <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">probe_side</span>)
{
    <span style="color: #46BDFF;">HashTable</span> <span style="color: #eedd82;">table</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : build_side)
        table.Insert(row);

    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">result</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : probe_side)
        <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">match</span> : table.Probe(row)) <span style="color: #525863;">// </span><span style="color: #525863;">You can have multiple build-side matches per probe-side row</span>
            result.Insert(match + row); <span style="color: #525863;">// </span><span style="color: #525863;">Assuming `+` concatenates two rows</span>
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>
<p>
In the context of a Hash Join, a Bloom filter can be used to avoid performing a hash table lookup. In a join, the heavy lifting
associated with building and probing the hash table is unavoidable for the intersection of the two input tables. Bloom filters,
never providing false negatives, efficiently short circuit rows that are definitely not in the intersection. There are two
possibilities for where to insert a Bloom filter:
</p>
<ul class="org-ul">
<li>Build-side bloom filter, where a bloom filter is populated while building the hash table. During probing, each row is checked
in the bloom filter first, and if <code>query</code> returns <code>false</code>, then the row is skipped.</li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">Dataset</span> <span style="color: #fcfcfc;">InnerHashJoin_BuildSideBloomFilter</span>(<span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">build_side</span>, <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">probe_side</span>)
{
    <span style="color: #46BDFF;">HashTable</span> <span style="color: #eedd82;">table</span>;
    <span style="color: #46BDFF;">BloomFilter</span> <span style="color: #eedd82;">bf</span>(build_side.size(), 0.01);
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : build_side)
    {
        bf.Insert(row);
        table.Insert(row);
    }

    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">result</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : probe_side)
    {
        <span style="color: #FF16B0;">if</span>(bf.Query(row))
            <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">match</span> : table.Probe(row)) <span style="color: #525863;">// </span><span style="color: #525863;">You can have multiple build-side matches per probe-side row</span>
                result.Insert(match + row); <span style="color: #525863;">// </span><span style="color: #525863;">Assuming `+` concatenates two rows</span>
    }
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>
<ul class="org-ul">
<li>Probe-side bloom filter, where prior to building the hash table, a bloom filter is populated with probe-side rows.
Then during the build phase, any build-side row that does not pass the bloom filter is skipped.</li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">Dataset</span> <span style="color: #fcfcfc;">InnerHashJoin_ProbeSideBloomFilter</span>(<span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">build_side</span>, <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">probe_side</span>)
{
    <span style="color: #46BDFF;">BloomFilter</span> <span style="color: #eedd82;">bf</span>(probe_side.size(), 0.01);
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : probe_side)
        bf.Insert(row);

    <span style="color: #46BDFF;">HashTable</span> <span style="color: #eedd82;">table</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : build_side)
        <span style="color: #FF16B0;">if</span>(bf.Query(row))
            table.Insert(row);

    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">result</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : probe_side)
        <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">match</span> : table.Probe(row)) <span style="color: #525863;">// </span><span style="color: #525863;">You can have multiple build-side matches per probe-side row</span>
            result.Insert(match + row); <span style="color: #525863;">// </span><span style="color: #525863;">Assuming `+` concatenates two rows</span>
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>

<p>
Whether either of these strategies is worth the overhead of constructing a bloom filter depends on four factors. In this analysis,
we define them as follows:
</p>
<ul class="org-ul">
<li>Probe-side selectivity \(s_P\) is the probability a given probe-side row will have a match on the build side.</li>
<li>Build-side selectivity \(s_B\) is the probability a given build-side row will have a match on the probe side.</li>
<li>The number of probe-side rows \(P\)</li>
<li>The number of build-side rows \(B\).</li>
</ul>
</div>

<div id="outline-container-org2764f31" class="outline-3">
<h3 id="org2764f31"><span class="section-number-3">2.1.</span> Build-side Bloom filter</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Build-side Bloom filter allows skipping hash table lookups during the probe phase. Thus we can expect the number of hash table
lookups to be \(s_PP + \epsilon(1 - s_P)P \approx Ps_P\) for small \(\epsilon\). If \(c_T\) is the cost of a hash table lookup and
\(c_F\) is the cost of a Bloom filter lookup, the total cost of the probe phase is \(c_FP + s_Pc_TP = (c_F + s_Pc_T)P\).
</p>

<p>
Observe that the amount of work needed for a Bloom filter lookup is the same as a Bloom filter insert (assuming
a single thread; insertion has extra overheads with multithreading). If we let \(c_B\) be the
cost per row during the build phase, we can derive the total cost of the join as \((c_F + c_B)B + (c_F + s_Pc_T)P\). So the
filter costs us \(c_F(P + B)\) while saving \((1 - s_P)c_TP\). Assuming that \(c_F \ll c_T\) and \(c_F \ll c_B\), we see that the impact
on build performance is negligible while the impact of \(c_T\) grows proportionally to \(s_P\). Further, notice that if
\(B \geq P\), \(c_F\) might start to be non-negligible cost. In particular, a Bloom filter stops making sense if
\(c_F(P + B) > (1 - s_P)c_TP\). In other words, as \(s_P\) approaches \(1\), this threshold becomes easier to cross, and a
Bloom filter becomes less worth the time.
</p>

<p>
When actually performing a hash join, a build-side Bloom filter allow for two modes of short circuiting:
</p>
<ul class="org-ul">
<li>Immediately eliminate a row without doing a hash table lookup
<ul class="org-ul">
<li>Inner Join</li>
<li>Left Semijoin</li>
<li>Right Semijoin</li>
<li>Right Antijoin</li>
<li>Right Outer Join</li>
</ul></li>
<li>Immediately output a row without doing a hash table lookup.
<ul class="org-ul">
<li>Left Antijoin</li>
<li>Left Outer Join</li>
<li>Full Outer Join</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org882fadc" class="outline-3">
<h3 id="org882fadc"><span class="section-number-3">2.2.</span> Probe-side Bloom filter</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Probe-side Bloom filter allows you to make the hash table much smaller at the cost of having to perform an extra scan. Hash
functions are rather expensive to compute, so using the canonical Bloom filter with \(k\) hash functions would easily dominate
the cost of using a Bloom filter on the probe side. What's worse is that a naive implementation for a probe-side Bloom filter
would the hashes twice (for \(2k\) hash evaluations)! The register-blocking Bloom filter with bit patterns discussed above solves
both problems by being compatible with the hash table's hash function. A smart implementation would cache the probe side's hashes
during Bloom filter build.
</p>

<p>
For the analysis of a probe-side filter, it's useful to introduce a similar quantity to \(s\) called \(s_B\): the probability of a
build-side row having a match on the probe side (as opposed to vice versa). The expected size of the hash table following a
probe-side Bloom filter is \(s_BB + \epsilon(1 - s_B)B \approx s_BB\) for small \(\epsilon\). So if \(s_B\) is 0.1, a Bloom filter
will reduce the size of the hash table tenfold! The total cost of the join ends up being
\(c_FP + c_FB + s_Bc_BB + c_TP = (c_F + c_T)P + (c_F + s_Bc_B)B\). A small \(s_B\) dramatically decreases the impact of \(c_B\)
(which can be quite expensive in multithreaded scenarios). Further, decreasing the size of the table could potentially make it
fit in a lower level of cache, decreasing \(c_T\) by an order of magnitude as well. Applying the filter costs \(c_F(P + B)\) but
saves \((1 - s_B)c_BB\), so it makes sense if \((1 - s_B)c_BB > c_F(P + B)\), not taking into account the effects of cache on \(c_T\).
So as \(s_B\) approaches \(0\) and \(P\) decreases, a probe-side Bloom filter makes more sense.
</p>

<p>
As before, a probe-side Bloom filter can help with either early-outputting or early-eliminating rows:
</p>
<ul class="org-ul">
<li>Joins that eliminate without inserting into the hash table are:
<ul class="org-ul">
<li>Inner Join</li>
<li>Left Semijoin</li>
<li>Left Antijoin</li>
<li>Left Outer Join</li>
<li>Right Semijoin</li>
</ul></li>
<li>Joins that can output immediately during the build phase are:
<ul class="org-ul">
<li>Right Antijoin</li>
<li>Right Outer Join</li>
<li>Full Outer Join</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org8675c80" class="outline-3">
<h3 id="org8675c80"><span class="section-number-3">2.3.</span> Fuzzy Hash Join</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The idea of a Fuzzy Hash Join is analogous to layering a Bloom filter over a build or probe: we perform a Hash Join
using <i>only</i> Bloom filters before proceeding with the full join. It works like this:
</p>
<ol class="org-ol">
<li>Build a build-side Bloom filter</li>
<li>Build a probe-side Bloom filter as the probe side streams in, filtering out entries using the build-side Bloom filter</li>
<li>Build the hash table using the probe-side Bloom filter</li>
<li>Proceed with probing on this smaller hash table using the filtered probe side.</li>
</ol>

<p>
In code:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">Dataset</span> <span style="color: #fcfcfc;">InnerHashJoin_Fuzzy</span>(<span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">build_side</span>, <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">probe_side</span>)
{
    <span style="color: #525863;">// </span><span style="color: #525863;">Step 1:</span>
    <span style="color: #46BDFF;">BloomFilter</span> <span style="color: #eedd82;">bf_build</span>(build_side.size(), 0.01);
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : build_side)
        bf.Insert(row);

    <span style="color: #525863;">// </span><span style="color: #525863;">Step 2:</span>
    <span style="color: #46BDFF;">BloomFilter</span> <span style="color: #eedd82;">bf_probe</span>(probe_side.size(), 0.01);
    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">filtered_probe</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : probe_side)
        <span style="color: #FF16B0;">if</span>(bf_build.Query(row))
        {
            bf_probe.Insert(row);
            filtered_probe.Insert(row);
        }

    <span style="color: #525863;">// </span><span style="color: #525863;">Step 3:</span>
    <span style="color: #46BDFF;">HashTable</span> <span style="color: #eedd82;">table</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : build_side)
        <span style="color: #FF16B0;">if</span>(bf_probe.Query(row))
            table.Insert(row);

    <span style="color: #525863;">// </span><span style="color: #525863;">Step 4:</span>
    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">result</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : filtered_probe)
        <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">match</span> : table.Probe(row)) <span style="color: #525863;">// </span><span style="color: #525863;">You can have multiple build-side matches per probe-side row</span>
            result.Insert(match + row); <span style="color: #525863;">// </span><span style="color: #525863;">Assuming `+` concatenates two rows</span>
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>

<p>
Notice that no Bloom filter needs to be built during hash table build, as anything that would not pass a build-side
Bloom filter would have been filtered out in step 2. 
</p>

<p>
The power of this algorithm comes from it taking into account both \(s_P\) and \(s_B\). The cost of the join becomes
\(c_F(P + B) + c_T(s_P + \epsilon(1 - s_P))P + c_B(s_B + \epsilon(1 - s_P))B\), which for small
\(\epsilon\) is approximately \(c_F(P + B) + c_Ts_PP + c_Bs_BB\). Thus the fuzzy join costs \(c_F(P + B)\) but saves
\(c_T(1 - s_P)P + c_B(1 - s_B)B\), so this strategy should be employed if \(c_T(1 - s_P)P + c_B(1 - s_B)B > c_F(P + B)\).
In other words, as \(s_P\) and \(s_B\) get smaller, this algorithm becomes more worth it. This qualitatively happens when
the intersection of the build and probe side is very small compared to both the build and probe side. 
</p>
</div>
</div>
</div>

<div id="outline-container-orgea3bbe6" class="outline-2">
<h2 id="orgea3bbe6"><span class="section-number-2">3.</span> Chain of Binary Hash Joins</h2>
<div class="outline-text-2" id="text-3">
<p>
We will now explore applications of Bloom filters for a chain of binary joins, of the form
\(R_0 \Join_1 R_2 \Join_2 \dots \Join_n R_n\). Conceptually, to evaluate this chain of joins, we build hash tables on
\(R_1, \dots, R_n\). Then for each row in \(R_0\), we probe it in \(R_1\). For each match, we probe it in \(R_2\), and
so on until \(R_n\). 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">Dataset</span> <span style="color: #fcfcfc;">InnerHashJoinChain</span>(<span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;<span style="color: #46BDFF;">Dataset</span>&gt; <span style="color: #eedd82;">build_side</span>, <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">probe_side</span>)
{
    <span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;HashTable&gt; <span style="color: #eedd82;">tables</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Dataset</span> &amp;<span style="color: #eedd82;">ds</span> : build_side)
    {
        <span style="color: #46BDFF;">HashTable</span> <span style="color: #eedd82;">table</span>;
        <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : ds)
            table.Insert(row);
        tables.push_back(table);
    }

    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">result</span> = probe_side;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">HashTable</span> &amp;<span style="color: #eedd82;">table</span> : tables)
    {
        <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">next</span>;
        <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : result)
            <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">match</span> : table.Probe(row))
                next.Insert(match + row);
        result = next;
    }
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>

<p>
A few observations about a chain of binary hash joins:
</p>
<ul class="org-ul">
<li>For a chain of \(n\) joins, there are \(n + 1\) inputs</li>
<li>Each join has a multiplicative effect on the number of rows: suppose each input row in \(R_0\) found on average \(1.5\) matches
in each of the \(n\) joins. Then we could potentially materialize \(1.5^nP\) rows!</li>
<li>Each join has the potential to filter out rows from the previous join</li>
<li>If there were a way to skip outputting rows from the previous join that are guaranteed to be filtered out in a later join,
we would skip needlessly materializing multiplicatively many rows.</li>
</ul>
</div>

<div id="outline-container-orgfca3bc9" class="outline-3">
<h3 id="orgfca3bc9"><span class="section-number-3">3.1.</span> Bloom Filter Pushdown</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Notice that for join \(\Join_i\), its join key columns must become available somewhere inside of the prefix chain
\(R_0 \Join_1 \dots \Join_{i - 1} R_{i - 1}\). These same key columns must exist inside of \(R_i\), and as such rows that
don't exist in \(R_i\) can be skipped, even before evaluating \(\Join_i\). A Bloom filter is perfect for this task!
</p>

<p>
This idea is called <i>pushdown</i>: each join \(\Join_i\) constructs its hash table and Bloom filter on \(R_i\) (denote the filter
\(F_i\)). It then pushes this Bloom filter down the chain to the first join \(\Join_j\) whose probe side input contains all of
the key columns of \(R_i\). Then prior to probing the hash table on \(R_j\), \(\Join_j\) runs its probe side input through \(F_i\)
and performs the join as normal.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #46BDFF;">Dataset</span> <span style="color: #fcfcfc;">InnerHashJoinChain_BloomFilterPushdown</span>(
    <span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;<span style="color: #46BDFF;">Dataset</span>&gt; <span style="color: #eedd82;">inputs</span>,
    <span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;JoinInfo&gt; <span style="color: #eedd82;">join_infos</span>,
    <span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;BloomFilter&gt; <span style="color: #eedd82;">filters</span> = {})
{
    <span style="color: #FF16B0;">if</span>(inputs.size() == 1) <span style="color: #525863;">// </span><span style="color: #525863;">Base case, just return the probe side</span>
        <span style="color: #FF16B0;">return</span> inputs[0];

    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">to_build</span> = inputs.back();
    <span style="color: #46BDFF;">JoinInfo</span> <span style="color: #eedd82;">join_info</span> = join_infos.back(); <span style="color: #525863;">// </span><span style="color: #525863;">Holds information about key columns</span>
    inputs.pop_back();
    join_infos.pop_back();

    <span style="color: #46BDFF;">HashTable</span> <span style="color: #eedd82;">table</span>;
    <span style="color: #46BDFF;">BloomFilter</span> <span style="color: #eedd82;">filter</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : to_build)
    {
        table.Insert(row, join_info);
        filter.Insert(row, join_info);
    }

    filters.push_back(filter);

    <span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;<span style="color: #46BDFF;">BloomFilter</span>&gt; <span style="color: #eedd82;">to_pushdown</span>;
    <span style="color: #96A1FF;">std</span>::<span style="color: #46BDFF;">vector</span>&lt;<span style="color: #46BDFF;">BloomFilter</span>&gt; <span style="color: #eedd82;">to_evaluate_here</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">BloomFilter</span> &amp;<span style="color: #eedd82;">filter</span> : filters)
    {
        <span style="color: #FF16B0;">if</span>(join_infos.back().ProbeSideContainsKeyColumns(join_info)) <span style="color: #525863;">// </span><span style="color: #525863;">If the probe side input contains the current key columns</span>
            to_pushdown.push_back(filter);
        <span style="color: #FF16B0;">else</span>
            to_evaluate_here.push_back(filter);
    }

    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">probe_side</span> = InnerHashJoinChain_BloomFilterPushdown(inputs, join_infos, to_pushdown);
    <span style="color: #46BDFF;">Dataset</span> <span style="color: #eedd82;">result</span>;
    <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">row</span> : probe_side)
    {
        <span style="color: #46BDFF;">bool</span> <span style="color: #eedd82;">passes</span> = <span style="color: #96A1FF;">true</span>;
        <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">BloomFilter</span> &amp;<span style="color: #eedd82;">filter</span> : to_evaluate_here)
            passes &amp;= filter.Query(row);

        <span style="color: #FF16B0;">if</span>(passes)
            <span style="color: #FF16B0;">for</span>(<span style="color: #FF16B0;">const</span> <span style="color: #46BDFF;">Row</span> &amp;<span style="color: #eedd82;">match</span> : table.Probe(row))
                result.Insert(match + row);
    }
    <span style="color: #FF16B0;">return</span> result;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0e23c9b" class="outline-2">
<h2 id="org0e23c9b"><span class="section-number-2">4.</span> References</h2>
<div class="outline-text-2" id="text-4">
<p>
[1] Broder, Andrei and Mitzenmacher, Michael, <i>Survey: Network Applications of Bloom Filters: A Survey.</i>, Internet Mathematics, 2003.</p>

<p>
[2] Lang, Harald and Neumann, Thomas and Kemper, Alfons and Boncz, Peter, <i>Performance-Optimal Filtering: Bloom Overtakes Cuckoo at High Throughput</i>, VLDB Endowment, 2019.</p>

<p>
[3] Putze, Felix and Sanders, Peter and Singler, Johannes, <i>Cache-, Hash-, and Space-Efficient Bloom Filters</i>, Association for Computing Machinery, 2010.</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Sasha</p>
<p class="date">Created: 2022-01-13 Thu 15:57</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
